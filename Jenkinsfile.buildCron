def getLowerRepoNameFromUrl(urlStr) {
    return (urlStr.tokenize('/')[3].split("\\.")[0]).toLowerCase()
}

def getLowerUserNameFromUrl(urlStr) {
    return (urlStr.tokenize('/')[2]).toLowerCase()
}

def userName = null
def repoNameLower = null
def jobName = null
pipeline {
    options {
        timeout(time: 10, unit: 'MINUTES')
    }
    agent { node { label 'kubepod' } }
    environment {
        JOB_NAME = "test"
        CMD = '["python3","-u","longrun.py"]'
        REPO_URL = "https://github.com/fans3210/TestRepo2NoDockerHub.git"
        REPO_CREDENTIAL_ID = "gh_fans3210"
        CALLER_USERID = "5f4b2838bd0475002923e228"
        SCHEDULE = "*/1 * * * *"
    }
    stages {
        stage('params validation') {
            steps {
                script {
                    if (env.CALLER_USERID == '' || env.CALLER_USERID == 'CALLER_USERID_PLACE_HOLDER') { // and/or whatever condition you want
                        currentBuild.result = 'ABORTED'
                        error('caller_userid not set or invalid')
                    }
                    if (env.REPO_URL == '' || env.REPO_URL == 'REPO_URL_PLACE_HOLDER') { // and/or whatever condition you want
                        currentBuild.result = 'ABORTED'
                        error('repo_url not set or invalid')
                    }
                    if (env.REPO_CREDENTIAL_ID == '' || env.REPO_CREDENTIAL_ID == 'REPO_CREDENTIAL_ID_PLACE_HOLDER') { // and/or whatever condition you want
                        currentBuild.result = 'ABORTED'
                        error('repo_credential_id not set or invalid')
                    }
                    if (env.CMD == '' || env.CMD == 'CMD_PLACE_HOLDER') {
                        currentBuild.result = 'ABORTED'
                        error('cmd not set or invalid')
                    }
                    if (env.JOB_NAME == '' || env.CMD == 'JOB_NAME_PLACE_HOLDER') {
                        currentBuild.result = 'ABORTED'
                        error('job name not set or invalid')
                    }
                     if (env.SCHEDULE == '' || env.CMD == 'SCHEDULE_PLACEHOLDER') {
                        currentBuild.result = 'ABORTED'
                        error('schedule not set or invalid')
                    }
                }
            }
        }
        stage('clone repo') {
            steps {
                git changelog: false, credentialsId: "$env.REPO_CREDENTIAL_ID", url: "$env.REPO_URL"
            }
        }
        stage('build docker image') {
            steps {
                echo 'pwd = ' + pwd()
                echo 'current workspace = ' + env.WORKSPACE
                sh 'ls'
                script {
                    userName = getLowerUserNameFromUrl(env.REPO_URL)
                    repoNameLower = getLowerRepoNameFromUrl(env.REPO_URL)
                    dockerImage = docker.build "$userName/$repoNameLower"
                }
            }
        }

        stage('build template string') {
            steps {
                script {
                    jobName = env.JOB_NAME
                    def yamlStr = """
                    apiVersion: batch/v1beta1
                    kind: CronJob
                    metadata:
                        name: ${jobName}
                        namespace: algo
                    spec:
                        schedule: ${env.SCHEDULE}
                        concurrencyPolicy: Forbid
                        successfulJobsHistoryLimit: 0
                        failedJobsHistoryLimit: 5
                        jobTemplate:
                            spec:
                                template:
                                    spec:
                                        volumes:
                                            - name: shared-volume
                                              emptyDir: {}
                                        initContainers:
                                            - name: pre
                                              image: mintel/docker-alpine-bash-curl-jq
                                              volumeMounts:
                                                - name: shared-volume
                                                  mountPath: /shared
                                              env:
                                                - name: JWT_SECRET
                                                  valueFrom:
                                                    secretKeyRef:
                                                        name: algosecret
                                                        key: JWT_SECRET
                                              command: ["sh"]
                                              args:
                                                - -c
                                                - |
                                                  mkdir /shared/dataset
                                                  mkdir /shared/scripts
                                                  echo 'hello world' > /shared/dataset/hello.txt
                                                  echo 'hello' > /shared/dataset/hello2.txt

                                                  cat - <<REALEND > shared/scripts/genToken.sh
                                                  #!/bin/bash
                                                  apk add --update coreutils
                                                  secret_key=\\\$JWT_SECRET
  
                                                  echo secret = \\\$secret_key
  
                                                  base64url() {
                                                      base64 -w 0 | tr '+/' '-_' | tr -d '='
                                                  }
  
                                                  jwt_header=\\\$(echo -n '{"alg":"HS256","typ":"JWT"}' | base64url)
                                                  echo 'jwt header = '
                                                  echo \\\$jwt_header
  
                                                  time_str() {
                                                      date +"%s"
                                                  }
  
                                                  now=\\\$(time_str)
                                                  echo 'now and expire = '
                                                  echo \\\$now
  
                                                  expire=\\\$((\\\$now + 100))
  
                                                  echo \\\$expire
  
                                                  echo calleruserid = ${env.CALLER_USERID}
                                                  jwt_claims=\\\$(cat <<EOF |
                                                  {
                                                      "id": "${env.CALLER_USERID}",
                                                      "sub": "${env.CALLER_USERID}",
                                                      "iat": \\\$now,
                                                      "exp": \\\$expire
                                                  }
                                                  EOF
                                                  jq -Mcj '.' | base64url)
                                                  echo 'jwt_claims = '
                                                  echo \\\$jwt_claims
  
                                                  jwt_signature=\\\$(echo -n "\\\${jwt_header}.\\\${jwt_claims}" | \
                                                      openssl dgst -sha256 -hmac "\\\$secret_key" -binary | base64url)
  
                                                  echo 'jwt signature = '
                                                  echo \\\$jwt_signature
  
                                                  jwt="\\\${jwt_header}.\\\${jwt_claims}.\\\${jwt_signature}"
  
                                                  echo 'final jwt = '
                                                  echo \\\$jwt
  
                                                  export jwt

                                                  REALEND
  
                                                  echo gen script is
                                                  cat /shared/scripts/genToken.sh
                                                  echo now run
                                                  chmod 777 /shared/scripts/genToken.sh
                                                  source /shared/scripts/genToken.sh
  
                                                  echo 'check jwt retrieved from bash'
                                                  echo \$jwt
  
                                                  curl --location --request GET 'http://ingress-nginx-controller.kube-system.svc.cluster.local/api/postgresdataservices/getMock' \
                                                  --header 'header1: 111' \
                                                  --header 'Host: caps4.com' \
                                                  --header "Authorization: Bearer \${jwt}" >/shared/dataset/input.json
  
                                                  cat /shared/dataset/input.json
  
  
  
                                                  sleep 30

                                            - name: core
                                              image: ${userName}/${repoNameLower}
                                              imagePullPolicy: Never
                                              volumeMounts:
                                                - name: shared-volume
                                                mountPath: /shared
                                              command: ${env.CMD}
                                              env:
                                                - name: PYTHONUNBUFFERED
                                                  value: "0"
                                                - name: DATASET_INPUT
                                                  valueFrom:
                                                    configMapKeyRef:
                                                        name: provisioned-container-config
                                                        key: DATASET_INPUT
                                        containers:
                                            - name: post
                                              image: busybox
                                              volumeMounts:
                                                - name: shared-volume
                                                  mountPath: /shared
                                              command: ["sh"]
                                              args:
                                                - -c
                                                - |
                                                  sleep 60
                                                  echo finished

                                        restartPolicy: OnFailure
                    """

                    writeFile file: "${jobName}.yaml", text: yamlStr
                }
            }
        }

        stage('provision pod') {
            steps {
                sh 'kubectl version'
                script {
                    try {
                        sh "kubectl delete cronjob ${jobName} -n algo"
                    } catch (Exception e) {
                        echo 'delete job got error: ' + e
                    }
                }
                echo 'check whether we have the yaml file'
                sh "kubectl apply -f ${jobName}.yaml"
            }
        }
        stage('save artifacts') {
            steps {
                    sh 'mkdir -p output'
                    sh 'ls'
                    sh "cp ./${jobName}.yaml ./output"
                    archiveArtifacts artifacts: 'output/*.yaml'
            }
        }
    }
}